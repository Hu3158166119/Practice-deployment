<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>8.9像素操作</title>
</head>

<style>
    * {
        margin: 0;
        padding: 0;
    }

    #canvas {
        width: 400px;
        height: 400px;
        border: 1px solid;
    }

    #canvas2 {
        width: 100px;
        height: 100px;
        border: 1px solid;
    }

    #hoveredColor {
        width: 200px;
        height: 400px;
        border: 1px solid;
    }

    #selectedColor {
        width: 200px;
        height: 400px;
        border: 1px solid;
    }

    .box {
        display: flex;
    }
</style>

<body>
    <div class="box">
        <canvas id="canvas" width="400" height="400"></canvas>
        <div id="hoveredColor"></div>
        <div id="selectedColor"></div>
        <div>
            <canvas id="canvas2" width="200" height="200"></canvas>
            <input type="checkbox" name="imageSmoothingEnabled" id="imageSmoothingEnabled">
            <label for="imageSmoothingEnabled">是否平滑</label>
        </div>
    </div>
    <div>
        <input type="radio" name="color" id="original">
        <label for="original">Original</label>
        <input type="radio" name="color" id="grayscale">
        <label for="grayscale">Grayscale</label>
        <input type="radio" name="color" id="inverted">
        <label for="inverted">Inverted</label>
        <input type="radio" name="color" id="sepia">
        <label for="sepia">Sepia</label>
    </div>
    <script>
        /** @type {HTMLCanvasElement} */
        var canvas = document.getElementById("canvas");
        var hoveredColor = document.getElementById("hoveredColor")
        var selectedColor = document.getElementById("selectedColor")
        var ctx = canvas.getContext("2d");

        /**
         * 创建一个新的图片对象     所有像素默认都是透明的
         * 
         * createImageData(width,height);   // 宽高
         * createImageData(imagedata);      // 现有iamgedata 的宽高 : 图像自身不允许复制
         * 
         * 返回值: 返回一个新的 ImageDate对象
         * 
         * 
         * 获取包含画布场景·像素数据·的对象
         * getImageData(left, top, width, height);
         * 
         * 返回值: [0~255,0~255,0~255,0~255] rgba 值 [3]/255 = 透明度
         * 
         * 对场景进行像素写入
         * putImageData(myImageData,x,y)
         * 
         * 得到一个 data URI 格式的链接 (如果画布长度或者宽度为0 则返回 data:)
         * toDataURL(type,encoderOptions)
         * type:图片格式 默认: “image/png”  encoderOptions:图片质量 0~1 越大越好
         * 
        */


        let img = new Image();
        // 该属性可以是一个 CORS 设置属性
        img.crossOrigin = "anonymous"
        img.src = './img/jietu.png'

        img.onload = function () {
            ctx.drawImage(img, 0, 0)
        }

        /**
         * 1.获取橡素点操作案例
         * 
        */
        function pick(event, destination) {
            var x = event.layerX;
            var y = event.layerY;
            // 获取图片像素信息
            var pixel = ctx.getImageData(x, y, 1, 1);
            var data = pixel.data;
            // 渲染
            const rgba = `rgba(${data[0]}, ${data[1]}, ${data[2]}, ${data[3] / 255})`;
            // 渲染赋值
            destination.style.background = rgba;
            destination.textContent = rgba;

            return rgba;
        }

        canvas.addEventListener('mousemove', (event) => {
            pick(event, hoveredColor)
            BlowUp(event)
        })

        canvas.addEventListener('click', (event) => {
            pick(event, selectedColor)
            let img = new Image()
            img.src = canvas.toDataURL('image/png',.5)
            document.querySelector('body').appendChild(img)
        })

        // hoveredColor.style.display = 'none'
        // selectedColor.style.display = 'none'

        /**
         * 2. 写入像素案例
         * 
        */

        const inputs = document.querySelectorAll('[name=color]');
        for (let i = 0; i < inputs.length; i++) {
            const element = inputs[i];
            element.addEventListener('change', (e) => {
                switch (e.target.id) {
                    case 'inverted':
                        return inverted()
                    case 'grayscale':
                        return grayscale()
                    case 'sepia':
                        return sepia()
                    default:
                        return original();
                }
            })
        }

        /**
         * 取反
        */
        function inverted() {
            ctx.drawImage(img, 0, 0);
            var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            var data = imageData.data
            for (let i = 0; i < data.length; i += 4) {
                data[i] = 255 - data[i]
                data[i + 1] = 255 - data[i + 1]
                data[i + 2] = 255 - data[i + 2]
            }
            ctx.putImageData(imageData, 0, 0)
        }
        /**
         * 褐色算法
        */
        function rgbToHsl(r, g, b) {
            r /= 255, g /= 255, b /= 255;
            var max = Math.max(r, g, b), min = Math.min(r, g, b);
            var h, s, l = (max + min) / 2;

            if (max === min) {
                h = s = 0; // achromatic
            } else {
                var d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                h /= 6;
            }

            return {
                h: h * 360,
                s: s,
                l: l
            };
        }
        function hslToRgb(h, s, l) {
            var r, g, b;

            if (s === 0) {
                r = g = b = l; // achromatic
            } else {
                function hue2rgb(p, q, t) {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1 / 6) return p + (q - p) * 6 * t;
                    if (t < 1 / 2) return q;
                    if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
                    return p;
                }

                var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                var p = 2 * l - q;
                r = hue2rgb(p, q, h + 1 / 3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1 / 3);
            }

            return {
                r: r * 255,
                g: g * 255,
                b: b * 255
            };
        }

        /**
         * 褐色
        */
        function sepia() {
            ctx.drawImage(img, 0, 0);
            var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            var data = imageData.data
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i]
                const g = data[i + 1]
                const b = data[i + 2]

                const hsl = rgbToHsl(data[i], data[i + 1], data[i + 2])
                hsl.h = (hsl.h + 180) % 360; // 将色相偏转到中间调
                hsl.s -= 0.1; // 减少饱和度

                // 反转HSL回RGB
                const rgb = hslToRgb(hsl.h, hsl.s, hsl.l);
                data[i] = rgb.r;
                data[i + 1] = rgb.g;
                data[i + 2] = rgb.b;
            }
            ctx.putImageData(imageData, 0, 0)
        }
        /**
         * 灰度
        */
        function grayscale() {
            ctx.drawImage(img, 0, 0);
            var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            var data = imageData.data
            for (let i = 0; i < data.length; i += 4) {
                var color = (data[i] + data[i + 1] + data[i + 2]) / 3
                data[i] = color
                data[i + 1] = color
                data[i + 2] = color
            }
            ctx.putImageData(imageData, 0, 0)
        }
        function original() {
            ctx.drawImage(img, 0, 0);
        }



        /** @type {HTMLCanvasElement} */
        var canvas2 = document.getElementById("canvas2");
        const imgSE = document.querySelector('#imageSmoothingEnabled')
        const ctx2 = canvas2.getContext('2d')
        imgSE.addEventListener('input', toggleSmoothing)
        imgSE.checked = true

        // 放大图片
        function BlowUp(event) {
            var x = event.layerX;
            var y = event.layerY;
            ctx2.drawImage(canvas, x - 5 < 0 ? 0 : x - 5, y - 5 < 0 ? 0 : y - 5, 10, 10, 0, 0, 400, 400)
        }

        // 设置平滑
        function toggleSmoothing (event) {
            ctx2.imageSmoothingEnabled = this.checked;
            ctx2.mozImageSmoothingEnabled = this.checked;
            ctx2.webkitImageSmoothingEnabled = this.checked;
            ctx2.msImageSmoothingEnabled = this.checked;
        };

        

        /**
         * 画布属性:
         * 
         * 图片是否平滑
         * imageSmoothingEnabled    属性值 Boolean :true/false
         *      获取时返回最新的设置的值
         * 
         * 
         * 
        */



    </script>
</body>

</html>